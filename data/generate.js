/**
 * Sample modeled based on pulling Arbitrum approvals
 */
const fs = require("fs");
const axios = require("axios");
const { ethers } = require("ethers"); // @5

// Constants
const START_BLOCK = 74286579;
const API_KEY = "U6CNF7VMRSUG3THUHSW5J5CNT5GVM7P1YE";
const ROUTER = "A7caC4207579A179c1069435d032ee0F9F150e5c";
const RPC = new ethers.providers.JsonRpcProvider("RPC_PROVIDER");

/**
 * Sleep async process for some ms
 * @param {number} ms
 * @returns awaitable promise
 */
function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

(async () => {
  let errors = [];
  let approvals = [];

  // Parse input (CSV export from https://arbiscan.io/exportData?type=address&a=0xA7caC4207579A179c1069435d032ee0F9F150e5c converted to JSON)
  const input = JSON.parse(fs.readFileSync("./arbitrum-input.json"));
  let fromAddresses = input.map((x) => x.From);
  fromAddresses = [...new Set(fromAddresses)];
  console.log("NUM Unique Addy: ", fromAddresses.length);

  for (const address of fromAddresses) {
    try {
      // Collect transactions from Etherscan API
      const { data } = await axios.get(
        `https://api.arbiscan.io/api?module=account&action=txlist&address=${address}&startblock=${START_BLOCK}&endblock=latest&page=1&offset=1000&sort=asc&apikey=${API_KEY}`
      );

      // Parse transaction data
      for (const tx of data.result) {
        const lowercase = tx.input.toLowerCase();
        if (
          lowercase.startsWith("0x095ea7b3") &&
          lowercase.includes(ROUTER.toLowerCase())
        ) {
          console.log(tx.hash);
          approvals.push(tx.hash);
        }
      }
    } catch {
      errors.push(address);
    }

    // Rate-limit handling
    await sleep(2500);
  }

  // Parse transactions
  let app = {};
  for (const tx of approvals) {
    const fullTx = await rpc.getTransaction(tx);
    const from = fullTx.from;
    const token = fullTx.to;

    // Create 2d mapping
    if (!app[from]) {
      app[from] = {};
    }

    try {
      // Make ERC20 token
      const t = new ethers.Contract(
        token,
        [
          "function allowance(address, address) external view returns (uint256)",
          "function balanceOf(address) external view returns (uint256)",
        ],
        RPC
      );
      // Get allowance
      const allow = await t.allowance(from, ROUTER);
      // If some allowance
      if (allow.toString() != "0") {
        // Add to mapping
        app[from][token] = {
          hash: fullTx.hash,
          allowance: allow.toString(),
          // Get user balance
          balance: (await t.balanceOf(from)).toString(),
        };
      }
    } catch {
      errors.push(fullTx.hash);
    }
  }

  // Throw errors
  console.error(errors);

  // Save approvals
  fs.writeFileSync("./arbitrum.json", JSON.stringify(app));
})();
